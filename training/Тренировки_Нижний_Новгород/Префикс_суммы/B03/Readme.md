![alt text](image.png)

### Резюме решения задачи

Основная идея решения заключается в использовании префиксных и суффиксных сумм для эффективного подсчета количества символов 'a' и 'b' на различных отрезках строки, чтобы найти максимально возможную длину "красивой" строки. Строка считается "красивой", если её можно разрезать на три части: первая и третья содержат только символы 'a', а вторая — только символы 'b'. Части могут быть пустыми.

### Алгоритм

1. **Построение массивов префиксных и суффиксных сумм:**
   - `pre_sum_a[i]` — количество символов 'a' в первых `i` символах строки.
   - `suf_sum_a[i]` — количество символов 'a' от позиции `i` до конца строки.
   - `sum_b[i]` — количество символов 'b' в первых `i` символах строки.
   
2. **Размер массивов `s.size() + 1`:**
   - Массивы `pre_sum_a`, `suf_sum_a` и `sum_b` создаются размером `s.size() + 1`, чтобы корректно учитывать случаи, когда одна или несколько частей строки могут быть пустыми.
   - Значения `pre_sum_a[0]` и `suf_sum_a[s.size()]` равны нулю, что позволяет обрабатывать ситуации, когда первая или третья часть строки пустая.
   - Это упрощает вычисления, так как обеспечивает корректные значения на границах, исключая необходимость в дополнительных проверках.

3. **Перебор всех возможных разбиений строки:**
   - Перебираются все возможные границы разбиения `(i, j)`, где `0 ≤ i ≤ j ≤ s.size()`.
   - Для каждого разбиения вычисляется длина "красивой" строки как `pre_sum_a[i] + (sum_b[j] - sum_b[i]) + suf_sum_a[j]`.

4. **Максимизация результата:**
   - Найденная длина "красивой" строки для каждого разбиения сравнивается с текущим максимальным значением, чтобы в итоге получить наибольшую возможную длину.

### Учет пустых частей строки

Использование массивов размера `s.size() + 1` позволяет корректно учитывать случаи, когда одна или несколько частей строки пусты:
- `pre_sum_a[0]` и `suf_sum_a[s.size()]` равны нулю, что обрабатывает ситуации с пустыми первой и третьей частями.
- Пустая вторая часть возможна, когда `i = j`, и её длина автоматически учитывается как ноль.

### Заключение

Этот подход позволяет эффективно вычислять максимальную длину "красивой" строки за время O(n^2), учитывая все возможные разбиения строки и позволяя обработать случаи с пустыми частями благодаря массивам размера `s.size() + 1`.
