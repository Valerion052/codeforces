# Алгоритм Флойда-Уоршелла

Алгоритм Флойда-Уоршелла — это метод нахождения кратчайших расстояний между всеми парами вершин во взвешенном графе. Он основан на динамическом программировании и работает за **O(N³)**.

## Когда использовать?
- Нужно найти кратчайшие пути между всеми вершинами  
- Граф ориентированный или неориентированный  
- Вес рёбер может быть отрицательным (но без отрицательных циклов)  
- Граф плотный (много рёбер), **N ≤ 100**  

## Как работает?
1. **Инициализируем матрицу расстояний:**  
   - `dist[i][j] = вес(i → j)`, если есть ребро.  
   - `dist[i][j] = INF`, если рёбра нет.  
   - `dist[i][i] = 0` (расстояние до самой себя).  

2. **Перебираем все вершины как промежуточные:**  
   Для каждой пары вершин `(i, j)` проверяем, улучшается ли путь через вершину `k`:
   
   `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`
   
   Если да, обновляем.

3. **После N итераций** в `dist[i][j]` хранятся кратчайшие расстояния.
```cpp
## Реализация на C++
#include <iostream>  
#include <vector>  

using namespace std;  

const int INF = 1e9; // "Бесконечность"  

void floydWarshall(vector<vector<int>>& dist, int n) {  
    for (int k = 0; k < n; ++k) {  
        for (int i = 0; i < n; ++i) {  
            for (int j = 0; j < n; ++j) {  
                if (dist[i][k] < INF && dist[k][j] < INF) {  
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }  
            }  
        }  
    }  
}  

int main() {  
    int n;  
    cin >> n;  
    vector<vector<int>> dist(n, vector<int>(n, INF));  

    // Читаем матрицу смежности  
    for (int i = 0; i < n; ++i) {  
        for (int j = 0; j < n; ++j) {  
            cin >> dist[i][j];  
            if (dist[i][j] == -1) dist[i][j] = INF; // -1 обозначает отсутствие пути  
        }  
    }  

    floydWarshall(dist, n);  

    // Вывод кратчайших расстояний  
    for (int i = 0; i < n; ++i) {  
        for (int j = 0; j < n; ++j) {  
            if (dist[i][j] == INF) cout << "INF ";  
            else cout << dist[i][j] << " ";  
        }  
        cout << "\n";  
    }  

    return 0;  
}  
```
## Сложность
- **Время:** O(N³) (три вложенных цикла).  
- **Память:** O(N²) (матрица расстояний).

## Дополнительные возможности
- Восстановление кратчайшего пути (используется `next[i][j]`).  
- Проверка на отрицательный цикл (`dist[i][i] < 0`).  

## Итог
- **Флойда-Уоршелла** лучше применять для **плотных графов** (много рёбер).  
- Если граф **разреженный** (M ≈ N), лучше использовать **Дейкстру или Беллмана-Форда**.  
- Удобен для **динамического программирования** в задачах на графы.  
