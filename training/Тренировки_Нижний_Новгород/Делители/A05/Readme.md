# Модуль (/mod)

## Обоснование корректности формулы `(ans * (x.second + 1)) % MOD`

### Свойство модуля
1. **Ассоциативность модуля для умножения**:
   \[
   (a \cdot b) \mod m = ((a \mod m) \cdot (b \mod m)) \mod m
   \]
   Это свойство позволяет применять модуль отдельно для множителей до их умножения.

2. **Идемпотентность модуля**:
   \[
   (a \mod m) \mod m = a \mod m
   \]
   Повторное взятие модуля не изменяет результат.

3. **Множитель меньше модуля**:
   Если \( a < m \), то:
   \[
   a \mod m = a
   \]
   Это позволяет пропустить \( \% MOD \), если переменная гарантированно меньше \( MOD \).

---

### Анализ формулы
1. Формула:
   \[
   (ans \cdot (x.second + 1)) \% MOD
   \]

2. Можно записать с учётом свойства модуля (**Ассоциативность модуля для умножения**):
   \[
   ((ans \% MOD) \cdot ((x.second + 1) \% MOD)) \% MOD
   \]

3. Так как после каждого шага вычислений \( ans \% MOD \) уже берётся, переменная \( ans \) всегда меньше \( MOD \), поэтому (**Идемпотентность модуля**):
   \[
   ans \% MOD = ans
   \]

4. Переменная \( x.second + 1 \) по условию задачи также заведомо меньше \( MOD \), поэтому (**Множитель меньше модуля**):
   \[
   (x.second + 1) \% MOD = x.second + 1
   \]

5. Упрощённая запись:
   \[
   (ans \cdot (x.second + 1)) \% MOD
   \]

---

### Вывод
Запись:
```cpp
ans = ans * (x.second + 1) % MOD;
```
является корректной, так как:
1. \( ans \) всегда находится в диапазоне \( [0, MOD - 1] \) (**Идемпотентность модуля**).
2. \( x.second + 1 \) по условию задачи также меньше \( MOD \) (**Множитель меньше модуля**).

Таким образом, в данном контексте можно безопасно использовать данную формулу без предварительного вычисления \( ans \% MOD \).
